# DOM과 브라우저 랜더링 과정

## DOM 이란?

- 웹페이지에 대한 인터페이스
- 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정볼를 담고 있다.

## 브라우저 랜더링

1. **HTML 다운로드**
2. HTML 파싱하여, **DOM 생성**
3. **CSS 파일 다운로드**
    - 2번 과정 중에, HTML의 attribute 에서 CSS 파일의 링크가 식별될 시 실행
4. CSS 파싱하여, **CSSOM 생성**
5. **DOM 을 순회**하며, 트리를 분석
    - 실제로 화면에 그려질 요소에만 방문한다. 
    - `display: none` 설정을 가진 요소는 배제한다.
    - 시간 등의 비용을 절약하기 위해, 방문노드를 제한하는 것이다.
6. **DOM 에 CSS 적용**
    - DOM 순회하며, 해당 노드에 대응하는 CSSOM 정보를 찾는다. 
    - CSS 적용 과정은 크게 두 가지로 나눠진다. (layout, painting)

<br/>
<br/>

### layout (= reflow)
- 브라우저 화면에 각 노드가 어느 위치에 놓여야 할지 계산하는 과정
- `최초 랜더링` & `재랜더링` 모두, 해당 과정 직후엔 필연적으로 painting 이 발생한다.

<br/>
<br/>

### painting
- 노드의 색과 같은 실제 유효한 모습을 그리는 과정
- 브라우저 화면의 pixel 이 각 요소와 대응된다.
- layout 과정 없이, painting 만 시행되기도 한다.


<br/>
<br/>
<br/>
<br/>


# 가상 DOM의 탄생 배경

> 랜더링하는 과정은 매우 복잡하고 많은 비용이 든다. 
하지만 요즘의 대다수 앱은 최초 랜더링 이후에도, 사용자와의 인터랙션을 통해 웹페이지가 변경되는 상황이 있다. 

## Single Page Application

**추가 랜더링 작업이 굉장히 빈번하다.**

> **왜냐하면,** 
일반적인 웹 페이지의 경우 변경사항이 발생하면 HTML 다운로드부터 랜더링을 다시 시작하지만, SPA 는 처음 생성된 DOM 을 기준으로 요소의 위치 등을 재계산해 반영한다.

<br/>
<br/>

### 장점
- 페이지 전환이 빠르다. (HTML,CSS 는 최초 1회만 다운로드)
- 깜박임 없는 자연스러운 웹페이지 탐색이 가능하다.

<br/>
<br/>

### 단점
- DOM 수정 등과 관련하여, 관리 비용이 크다.
- 개발자는 DOM 변경 후 결과물만 신경쓰고 싶지만, 변경사항을 추적하여 어떻게 변경이 일어나는지 추척해야한다.


## 가상 DOM

- 실제 브라우저의 DOM 이 아니다. 
- 리액트가 관리하는 가상의 DOM 을 의미한다. 
- 변경사항이 있을 경우,
    - 실제 DOM 은 일단 건드리지 않는다.
    - 가상 DOM 을 수정한 뒤, 한번에 실제 DOM 에 반영한다.

### 장점
- 실제로는 여러번 발생했을 랜더링 과정을 최소화할 있다.
- 랜더링 효율성 측면에서, 브라우저와 개발자의 부담이 줄어든다.

### 단점
- 실제 DOM 을 수정하는 것보다, 가상 DOM 수정 후 반영(=커밋) 하는 과정이 약간 더 느리다.


<br/>
<br/>
<br/>
<br/>


# 가상 DOM 을 위한 아키텍처, 리액트 파이버

## Fiber 란?

- 리액트에서 관리하는 평범한 자바스크립트 객체이다.
- **Fiber Reconciler** 가 관리한다. 

<br/>
<br/>

### 재조정(Reconciliation)

<U>가상 DOM 과 실제 DOM</U> (Fiber Reconciler 는 엄밀하게 말해서, **current Tree** 와 **workInProgress Tree**) 을 비교해 변경사항을 수집하고 랜더링을 요구하는 작업(=알고리즘)

<br/>
<br/>


### Fiber 의 장점

1. 작업을 작은 단위로 분할 -> 작업 단위 간의 **우선순위**를 정할 수 있다. 
2. 작업을 **중지**, 나중에 **재시작**할 수 있다.
3. 이전에 했던 작업을 **재사용**하거나, 불필요한 작업은 **페기**할 수 있다.
4. Fiber Reconciliation 의 랜더 과정은 **비동기**로 일어난다.

### Fiber 의 작업 처리 과정

1. 랜더 단계에서, 리액트는 사용자에게 노출되지 않는 모든 비동기 작업을 수행한다.
    - 비동기로 수행하기 때문에, 사용자와의 상호작용에 영향을 주지 않는다.
    - 우선순위가 낮다면 이번 랜더링 과정에 반영하지 않을 수 있다. 
2. 커밋 단계에서 종합된 변경사항을 DOM 에 적용한다. 
    - 이 과정은 **동기적**으로 실행되기 때문에 중단할 수 없다.


### Fiber 의 구성

<br/>

#### Fiber vs React Element
    모두 Javascript 객체로 이뤄져 있으나, 아래와 같은 차이가 있다.

      · React Element 는 랜더링이 발생할 때마다 새롭게 생성된다. 
      · Fiber 는 컴포넌트의 최초 마운트 시점에 생성되어 거의 재사용된다.

<br/>

#### Fiber 는 DOM 노드, React Component 등 과 항상 1대1 관계를 갖는다. 
(tag 속성을 확인하면, 어떤 객체와 1대1 관계인지 알 수 있다.)

<br/>
<br/>

### Fiber Tree
- current: 현재 DOM 상태를 반영한 value UI (= fiber tree)
- workInProgress: 변경사항이 처리한 value UI

Commit 단계에서 current Tree 를 참조하는 포인터를 workInProgress 로 변경함으로서, 많은 변경사항을 빠르게 DOM 에 적용할 수 있다.

> **더블 버퍼링**
> 
> 컴퓨터 그래픽 분야에서 먼저 사용된 용어로, 두 개의 트리를 교체하며 화면을 전화하는 기법. 
>
> frame 전환 중에 불완전한 트리를 노출하지 않기 위해 사용한다.

<br/>
<br/>

### Fiber 의 작업 순서

> **작업 흐름**
> 
> 1. children -> sibling -> return(부모) 순으로 트리 순회
> 2. 노드 방문 시, beginWork() 호출
> 3. children 이 없다면, completeWork() 호출
> 4. children 이 있다면, 1번 순서대로 탐색이 종료된 후에 completeWork() 호출 
> 5. 루트 노드에서 completeWork() 호출되면, commitWork() 가 실행되고 commit 단계에 돌입

<br/>
<br/>
<br/>
<br/>

# 파이버와 가상 DOM

- 가상 DOM 은 fiber 로 이뤄진다. -> 🅾️
- fiber Tree == 가상 DOM -> ❎

## 가상 DOM
- 가상 DOM 은 웹 애플리케이션에서만 통용되는 개념이다. (사실, React 팀에서 밝힌 공식적인 용어도 아니다.)
- 브라우저가 아닌 환경(ex) 리액트 네이티브) 에서는 DOM 아닌 다른 개념의 랜더링 모델이 있다.
- fiber 는 UI 의 상태를 값으로 관리하는 객체이기 때문에, 브라우저를 포함한 네이티브 환경에서도 재조정자로써 활용되고 있다. 
   - react 에서 지원하는 UI library 일 경우, render는 app 환경에 따라 다르지만, reconciler 는 동일하다. 