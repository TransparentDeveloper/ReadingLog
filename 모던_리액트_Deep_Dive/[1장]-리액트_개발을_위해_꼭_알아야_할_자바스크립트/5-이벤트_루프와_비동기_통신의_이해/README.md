## Process 와 Thread

**Process**: 운영체제로부터 메모리 상의 자원을 할당받아, 처리되는 작업 단위이다. 하나의 프로세스로 동작하는 프로그램은, 해당 프로세스가 모든 작업을 처리한다.

프로세스는 운영체제로부터 할당 받은 공간을 아래와 같이 크게 4 개의 공간으로 분리하여, 자원을 관리한다.

> Code
- 개발자가 작성한 소스코드를 cpu 가 해석할 수 있도록 기계어 형태로 저장

> Data
- 프로세스 실행 시, 곧바로 로드되어야 할 전역변수 혹은 static 메서드 등을 관리

> Stack
- 함수의 지역변수, 반환 주소, 매개변수 등을 하나의 프레임으로 하여, 함수 호출 관계를 스택구조로 관리

> Heap
- 크기가 유동적으로 변화하는 자원(객체의 인스턴스 등) 등 을 관리
- 개발자가 직접 메모리 할당과 해제를 지정해줘야 한다. (메모리 누수가 발생할 수 있다.)



> (이미지 첨부하기 - process)

<br/>

**Thread**: 프로세스에 할당된 자원을 활용하는 작업실행의 단위이다. 하나의 프로세스는 여러 쓰레드를 만들 수 있고, 각 쓰레드는 프로세스의 자원을 공유한다.

<br/>

**Multi Thread**
- 소프트웨어가 복잡해지면서, 여러 개의 복잡한 작업을 동시에 수행해야할 필요가 생겼다. 
- 한 프로세스 내에서 다수의 thread 가 동시 다발적인 작업을 독립적으로 수행하는 것을 멀티 스레드라고 한다.
- 한 프로세스 내에서 각 스레드는 Stack 공간만 개별적으로 관리하고 있기 때문에, 독립적인 작업이 가능하다.
- 그 외의 프로세스 자원은 모두 공유하기 때문에, 공유 자원 접근 방식을 제대로 지정하지 않으면 프로세스를 종료시킬 수 있다.

> (이미지 첨부하기 - process)

<br/>
<br/>
<br/>

## Javascript 는 Single Thread 언어
- 모든 작업을 하나의 스레드로 관리한다.
- 한번에 하나씩 모든 작업을 "동기식" 처리한다.

<br/>
<br/>

### 비동기 처리?
비동기 처리란, 동시에 발생한 이벤트에 대해 (가령, 데이터 패칭과 사용자의 입력이 동시간에 발생한 경우), single thread 가 이를 순차적으로 처리할 수 있도록 작업 스케줄링을 하는 것 => **_*이벤트 루프의 핵심 역할_**

<br/>
<br/>
<br/>
<br/>

# 이벤트 루프 (Event Loop)
_(* V8 엔진을 기준으로 작성..)_

> (이미지 첨부하기 - event loop)

- 비동기 처리 매커니즘
- Javascript 엔진에 포함된 개념이 아니다.

<br/>
<br/>
<br/>


## 동작원리
1. call stack 을 확인한다. 
    - call stack 은 함수를 호출해 작업을 처리하는 공간이다.
    - 곧바로 실행해야할 작업이 있는지를 확인한다.

2. call stack 이 비었다면, task queue (=callback queue) 의 콜백함수(비동기 작업)를 하나씩 call stack 으로 이동시킨다. 
    - task queue 는 곧바로 처리가능한(=runnable) 콜백함수를 모아 놓은 공간이다.
    - 가장 오래된 것부터 하나씩 옮긴다. (실제로 queue 구조는 아니지만, queue 와 같이 FIFO 방식으로 처리된다.)


```ts
const a = () => {
  setTimeout(
    // ⬇️[비동기 처리]⬇️
    () => { 
    console.log("a")
    }
    // ⬆️[비동기 처리]⬆️
  ,0)
}

const b = () => {
  console.log("b")
}


const c = () => {
  console.log("c")
}

a()
b()
c()

/* ✅ 정상출력
  b
  c
  a
*/
```

<br/>
<br/>
<br/>

## MicroTask queue

- 이벤트 루프가 관리하는 callback queue 에는 비동기 로직의 우선순위에 따라 Task queue (= Macro queue) 와 MicroTask queue 가 있다.
- MicroTask queue 를 우선적으로 관리한다.

<br/>
<br/>

### 예시
- Promise 객체의 .then(), .catch(), .finally() 메서드의 콜백.
- DOM 관련 비동기 작업.

<br/>
<br/>

### 비교
DOM 이벤트 콜백(addEventListener 등), setTimeout, setInterval 등은 매크로 태스크 큐에 들어가며, 마이크로 태스크 큐보다 우선순위가 낮다.

<br/>
<br/>

### 동작원리
1. 콜 스택이 비어 있을 때:
  - 콜 스택이 비어 있을 때, 이벤트 루프는 마이크로 태스크 큐의 작업을 처리한다. 
  - 마이크로 태스크 큐는 FIFO(First In, First Out) 방식으로 처리한다.


2. 마이크로 태스크 큐 처리:
  - 이벤트 루프는 마이크로 태스크 큐가 완전히 비어 있을 때까지 마이크로 태스크를 계속 처리한다. 
  - 새로운 마이크로 태스크가 생성되더라도, 이 새로운 마이크로 태스크도 계속 처리된다.

3. 마이크로 태스크 큐 처리 이후:
  - 이벤트 루프는 매크로 태스크 큐를 확인하여 다음 매크로 태스크를 콜 스택에 할당한다.
  - 매크로 태스크 실행 중에 새로운 마이크로 태스크가 생성되면 매크로 태스크를 다 마무리한 후, 마이크로 태스크 큐를 다시 확인하여 추가된 마이크로 태스크를 처리한다.
