# useEffect

- 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만들기 위해 실행한다.

- 데이터 바인딩 이나 옵저버와 같은 **특별한 기능을 통해 값의 변화를 관찰하는 것이 아니고**, 랜더링 될 때마다 **의존성의 값**이 이전과 **다른 하나라도 있다면 부수효과를 실행**하는 **평범한 함수**이다.


## 클린업 함수의 목적

```tsx
// 예시)
const Component = () => {
  useEffect(()=>{
    return () => {
      /**
       * 클린업 함수 내부
       */
    }
  },[])
}
```

>  Component 가 랜더링 되기 직전 환경(있다면,,) 을 기억하고, 접근할 수 있다.

> useEffect 의 콜백을 실행되기 전, 이전의 클린업 함수가 존재했다면 해당 클린업 함수를 먼저 실행한 후, 콜백을 실행한다.


### 클린업(함수형 컴포넌트) 과 Unmount(클래스형 컴포넌트)
클래스형 컴포넌트의 생명주기 메서드의 언마운트 란, 특정 컴포넌트가 DOM 에서 사라지는 것을 의미하는 클래스형 컴포넌트 용이다. 

클린업 함수는 컴포넌트가 업데이트 되는 중에도 실행되며, 이전 상태를 정리해주는 개념이다.



## 의존성 배열

일정 길이의 배열일 수도 있고, 빈 배열일 수도 있고, 배열 자체를 넣지 않을 수도 있다.


### 빈배열인 경우

```tsx
useEffect(()=>{
  ...
},[])
```

비교할 의존성이 없는 경우이다. 최초 랜더링 직후에 실행된 다음부터 더 이상 실행되지 않는다.

### 배열이 없는 경우

```tsx
useEffect(()=>{
  ...
})
```

의존성을 비교할 필요가 없다고 판단해, 랜더링할 때마다 콜백이 실행된다.

> _주로 컴포넌트가 랜더링되었는지 테스트하기 위해 사용한다._

#### 다음의 차이는?

```tsx
// 1
const ComponentA = () => {
  useEffect(()=>{
    console.log("랜더링 되었다.")  
  })
  return (...)
}

// 2
const ComponentB = () => {
  console.log("랜더링 되었다.")
  return (...)
}
```

1. `1` 과 같은 방식은 서버사이드 랜더링이 불가능하다.
    - **useEffect 는 클라이언트 사이드에서 실행하는 것을 전제,보장한다.**

2. `1` 의 경우 함수형 컴포넌트의 반환을 우선 랜더링한 뒤, 콜백을 실행하여 부수효과를 처리한다. 하지만 `2` 의 경우, 연산이 모두 끝난 뒤 랜더링이 이뤄진다.
    - **무거운 작업이 있다면, 랜더링을 방해하므로 성능에 악영향을 미칠 수 있다.**


## useEffect의 구현

의존성 배열의 이전값과 현재값을 얕은 비교(`Object.is()`) 이다.
하나의 요소라도 이전과 다른 값을 가진다면, 콜백이 실행된다.

## useEffect를 사용할 때 주의할 점

### eslint-disabled-line react-hooks/exhaustive-deps 주석은 최대한 자제하라

해당 주석을 사용할 경우, 의존성 배열을 정확히 채우지 않아도 경고가 발생하지 않는다. 

그러나 의존성 배열을 넘기지 않은 채 콜백 함수 내부에서 특정 값을 사용한다면 부수 효과 실행이 잘못된 시점에 동작할 수 있음을 의미한다. (_특정 값을 관찰하여, 변화가 발생할 경우 부수효과를 처리해야한다._)



### useEffect의 첫 번째 인수에 함수명을 부여하라

### 거대한 useEffect를 만들지 마라

### 불필요한 외부 함수를 만들지 마라

